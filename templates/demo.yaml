Resources:
  LambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: "LambdaExecutionPolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "lambda:InvokeFunction"
                Resource: "*"  #Specify allowed Lambda function ARNs here, e.g., "arn:aws:lambda:<region>:<account-id>:function:<function-name>"
              - Effect: "Allow"
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "arn:aws:logs:::*"

  MyLambdaFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Handler: "index.handler"
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import pg8000
          import json

          # Database connection details
          DB_HOST = 'database-1-instance-1.cj8w4gsoqqs3.eu-north-1.rds.amazonaws.com'
          DB_PORT = 5432  # Default PostgreSQL port
          DB_NAME = 'postgres'  # Replace with your actual database name
          DB_USER = 'postgres'  # Replace with your actual username
          DB_PASSWORD = 'venkat123'  # Replace with your actual password

          # Lambda function handler
          def lambda_handler(event, context):
              cursor = None  # Initialize cursor
              conn = None  # Initialize connection
              try:
                  # Check if 'httpMethod' exists in event
                  if 'httpMethod' not in event:
                      raise KeyError("'httpMethod' key not found in event")
                  
                  # Establish connection to the PostgreSQL database using pg8000
                  conn = pg8000.connect(
                      host=DB_HOST,
                      port=DB_PORT,
                      database=DB_NAME,
                      user=DB_USER,
                      password=DB_PASSWORD
                  )
                  cursor = conn.cursor()

                  # Check the HTTP method and perform actions based on it
                  if event['httpMethod'] == 'GET':
                      cursor.execute("SELECT * FROM clients;")  # Replace with your table name
                      rows = cursor.fetchall()
                      
                      # Prepare response body
                      data = []
                      for row in rows:
                          data.append({
                              'client_id': row[0],  # Assuming the first column is client_id
                              'client_name': row[1]  # Assuming the second column is client_name
                          })
                      
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'message': 'Data retrieved successfully',
                              'data': data
                          }),
                          'headers': {
                              'Content-Type': 'application/json'
                          }
                      }

                  elif event['httpMethod'] == 'POST':
                      # Example for inserting data from the POST request body
                      request_data = json.loads(event['body'])
                      client_name = request_data.get('client_name')  # Assuming 'client_name' is passed in the body
                      cursor.execute("INSERT INTO clients (client_name) VALUES (%s);", (client_name,))
                      conn.commit()

                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'message': 'Data inserted successfully!'
                          }),
                          'headers': {
                              'Content-Type': 'application/json'
                          }
                      }

                  else:
                      # Respond with an error message if the method is neither GET nor POST
                      return {
                          'statusCode': 405,  # Method Not Allowed
                          'body': json.dumps({
                              'message': 'The method you are calling is not correct. Please use GET or POST.'
                          }),
                          'headers': {
                              'Content-Type': 'application/json'
                          }
                      }

              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'message': str(e)
                      }),
                      'headers': {
                          'Content-Type': 'application/json'
                      }
                  }

              finally:
                  # Close the connection and cursor if they were initialized
                  if cursor:
                      cursor.close()
                  if conn:
                      conn.close()

                Runtime: "python3.9"
                Timeout: 15

 
  MyApiGateway:
    Type: "AWS::ApiGateway::RestApi"
    Properties:
      Name: "MyApiGateway"
 
  MyApiGatewayResource:
    Type: "AWS::ApiGateway::Resource"
    Properties:
      ParentId: !GetAtt MyApiGateway.RootResourceId
      PathPart: "hello"
      RestApiId: !Ref MyApiGateway
 
  MyApiGatewayMethod:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "GET"
      ResourceId: !Ref MyApiGatewayResource
      RestApiId: !Ref MyApiGateway
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub
          - "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations"
          - { LambdaArn: !GetAtt MyLambdaFunction.Arn }
 
  LambdaApiGatewayPermission:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName: !GetAtt MyLambdaFunction.Arn
      Principal: "apigateway.amazonaws.com"
      SourceArn: !Sub
        arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${MyApiGateway}/*
 
  # MyVpc:
  #   Type: "AWS::EC2::VPC"
  #   Properties:
  #     CidrBlock: "10.0.0.0/16"
      
  MyDBSecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupDescription: "Allow access to PostgreSQL"
      VpcId: vpc-0f318dd41e9ac6436
      SecurityGroupIngress:
        - IpProtocol: "tcp"
          FromPort: 5432
          ToPort: 5432
          CidrIp: "10.0.0.0/16"

  MyPostgresDB:
    Type: "AWS::RDS::DBInstance"
    Properties:
      AllocatedStorage: "20"
      DBInstanceClass: "db.t3.micro"
      Engine: "postgres"
      MasterUsername: "mydbuser"
      MasterUserPassword: "mydbpassword"
      DBName: "MyDatabase"
      # DBSubnetGroupName: !Ref MyDBSubnetGroup
      PubliclyAccessible: false
      BackupRetentionPeriod: 7
      VPCSecurityGroups:
        - !GetAtt MyDBSecurityGroup.GroupId

# Parameters:
#   VPCId:
#     Type: AWS::EC2::VPC::Id